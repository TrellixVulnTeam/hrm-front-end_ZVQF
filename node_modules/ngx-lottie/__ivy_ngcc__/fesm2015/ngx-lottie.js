import * as i0 from '@angular/core';
import { InjectionToken, Injectable, NgZone, Inject, Directive, PLATFORM_ID, Input, Output, ElementRef, Self, Component, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { from, of, animationFrameScheduler, Subject, BehaviorSubject, defer, Observable } from 'rxjs';
import { map, publishReplay, refCount, observeOn, filter, switchMap, takeUntil } from 'rxjs/operators';
import * as i1 from '@angular/platform-browser';
import { makeStateKey, TransferState } from '@angular/platform-browser';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/platform-browser';

const _c0 = ["container"];
const LOTTIE_OPTIONS = new InjectionToken('LottieOptions');

function convertPlayerOrLoaderToObservable(player) {
    const playerOrLoader = player();
    if (playerOrLoader instanceof Promise) {
        return from(playerOrLoader).pipe(map(module => module.default || module), publishReplay(1), refCount());
    }
    else {
        return of(playerOrLoader);
    }
}
class AnimationLoader {
    constructor(ngZone, options) {
        this.ngZone = ngZone;
        this.options = options;
        this.player$ = convertPlayerOrLoaderToObservable(this.options.player).pipe(observeOn(animationFrameScheduler));
    }
    loadAnimation(options) {
        return this.player$.pipe(map(player => this.createAnimationItem(player, options)));
    }
    resolveOptions(options, container) {
        return Object.assign({
            container,
            renderer: 'svg',
            loop: true,
            autoplay: true,
        }, options);
    }
    createAnimationItem(player, options) {
        return this.ngZone.runOutsideAngular(() => player.loadAnimation(options));
    }
}
AnimationLoader.ɵfac = function AnimationLoader_Factory(t) { return new (t || AnimationLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(LOTTIE_OPTIONS)); };
AnimationLoader.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: AnimationLoader, factory: AnimationLoader.ɵfac });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
AnimationLoader.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [LOTTIE_OPTIONS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AnimationLoader, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOTTIE_OPTIONS]
            }] }]; }, null); })();

class BaseDirective {
    constructor(ngZone, platformId, animationLoader) {
        this.ngZone = ngZone;
        this.platformId = platformId;
        this.animationLoader = animationLoader;
        this.options = null;
        this.containerClass = null;
        this.styles = null;
        /**
         * `animationCreated` is dispatched after calling `loadAnimation`.
         */
        this.animationCreated = this.getAnimationItem();
        /**
         * `complete` is dispatched after completing the last frame.
         */
        this.complete = this.awaitAnimationItemAndStartListening('complete');
        /**
         * `loopComplete` is dispatched after completing the frame loop.
         */
        this.loopComplete = this.awaitAnimationItemAndStartListening('loopComplete');
        /**
         * `enterFrame` is dispatched after entering the new frame.
         */
        this.enterFrame = this.awaitAnimationItemAndStartListening('enterFrame');
        /**
         * `segmentStart` is dispatched when the new segment is adjusted.
         */
        this.segmentStart = this.awaitAnimationItemAndStartListening('segmentStart');
        /**
         * Original event name is `config_ready`. `config_ready` is dispatched
         * after the needed renderer is configured.
         */
        this.configReady = this.awaitAnimationItemAndStartListening('config_ready');
        /**
         * Original event name is `data_ready`. `data_ready` is dispatched
         * when all parts of the animation have been loaded.
         */
        this.dataReady = this.awaitAnimationItemAndStartListening('data_ready');
        /**
         * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
         * when elements have been added to the DOM.
         */
        this.domLoaded = this.awaitAnimationItemAndStartListening('DOMLoaded');
        /**
         * `destroy` will be dispatched when the component gets destroyed,
         * it's handy for releasing resources.
         */
        this.destroy = this.awaitAnimationItemAndStartListening('destroy');
        /**
         * `error` will be dispatched if the Lottie player could not render
         * some frame or parse config.
         */
        this.error = this.awaitAnimationItemAndStartListening('error');
        this.destroy$ = new Subject();
        this.loadAnimation$ = new Subject();
        this.animationItem$ = new BehaviorSubject(null);
        this.setupLoadAnimationListener();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroyAnimation();
    }
    loadAnimation(changes, container) {
        this.loadAnimation$.next([changes, container]);
    }
    getAnimationItem() {
        return defer(() => this.animationItem$).pipe(filter((animationItem) => animationItem !== null));
    }
    awaitAnimationItemAndStartListening(name) {
        return this.getAnimationItem().pipe(switchMap(animationItem => 
        // `fromEvent` will try to call `removeEventListener` when `unsubscribe()` is invoked.
        // The problem is that `ngOnDestroy()` is called before Angular unsubscribes from
        // `@Output()` properties, thus `animationItem` will be `null` already, also `lottie-web`
        // removes event listeners when calling `destroy()`.
        new Observable(observer => {
            animationItem.addEventListener(name, event => {
                this.ngZone.runOutsideAngular(() => {
                    observer.next(event);
                });
            });
        })));
    }
    setupLoadAnimationListener() {
        this.loadAnimation$
            .pipe(filter(([changes]) => isPlatformBrowser(this.platformId) && changes.options !== undefined), switchMap(([changes, container]) => {
            this.destroyAnimation();
            return this.animationLoader.loadAnimation(this.animationLoader.resolveOptions(changes.options.currentValue, container));
        }), takeUntil(this.destroy$))
            .subscribe(animationItem => {
            this.animationItem$.next(animationItem);
        });
    }
    destroyAnimation() {
        const animationItem = this.animationItem$.getValue();
        // The `ng-lottie` component or the `lottie` directive can be destroyed
        // before the `animationItem` is set, thus it will fail with
        // `Cannot read property 'destroy' of null`.
        // Potentially it can happen if the directive gets destroyed before change
        // detection is run.
        if (animationItem === null) {
            return;
        }
        // `destroy()` will remove all events listeners.
        animationItem.destroy();
        this.animationItem$.next(null);
    }
}
BaseDirective.ɵfac = function BaseDirective_Factory(t) { return new (t || BaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
BaseDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseDirective, selectors: [["", "lottie", ""]], inputs: { options: "options", containerClass: "containerClass", styles: "styles" }, outputs: { animationCreated: "animationCreated", complete: "complete", loopComplete: "loopComplete", enterFrame: "enterFrame", segmentStart: "segmentStart", configReady: "configReady", dataReady: "dataReady", domLoaded: "domLoaded", destroy: "destroy", error: "error" } });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
BaseDirective.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: AnimationLoader }
];
/** @type {!Object<string, !Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
BaseDirective.propDecorators = {
    options: [{ type: Input }],
    containerClass: [{ type: Input }],
    styles: [{ type: Input }],
    animationCreated: [{ type: Output }],
    complete: [{ type: Output }],
    loopComplete: [{ type: Output }],
    enterFrame: [{ type: Output }],
    segmentStart: [{ type: Output }],
    configReady: [{ type: Output }],
    dataReady: [{ type: Output }],
    domLoaded: [{ type: Output }],
    destroy: [{ type: Output }],
    error: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseDirective, [{
        type: Directive,
        args: [{ selector: '[lottie]' }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: AnimationLoader }]; }, { options: [{
            type: Input
        }], containerClass: [{
            type: Input
        }], styles: [{
            type: Input
        }], animationCreated: [{
            type: Output
        }], complete: [{
            type: Output
        }], loopComplete: [{
            type: Output
        }], enterFrame: [{
            type: Output
        }], segmentStart: [{
            type: Output
        }], configReady: [{
            type: Output
        }], dataReady: [{
            type: Output
        }], domLoaded: [{
            type: Output
        }], destroy: [{
            type: Output
        }], error: [{
            type: Output
        }] }); })();

class LottieDirective extends BaseDirective {
    constructor(ngZone, platformId, host, animationLoader) {
        super(ngZone, platformId, animationLoader);
        this.host = host;
    }
    ngOnChanges(changes) {
        super.loadAnimation(changes, this.host.nativeElement);
    }
}
LottieDirective.ɵfac = function LottieDirective_Factory(t) { return new (t || LottieDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef, 2), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
LottieDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LottieDirective, selectors: [["", "lottie", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
LottieDirective.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef, decorators: [{ type: Self }] },
    { type: AnimationLoader }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LottieDirective, [{
        type: Directive,
        args: [{ selector: '[lottie]' }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef, decorators: [{
                type: Self
            }] }, { type: AnimationLoader }]; }, null); })();

class LottieComponent extends BaseDirective {
    constructor(ngZone, platformId, animationLoader) {
        super(ngZone, platformId, animationLoader);
        this.width = null;
        this.height = null;
        this.container = null;
    }
    ngOnChanges(changes) {
        super.loadAnimation(changes, this.container.nativeElement);
    }
}
LottieComponent.ɵfac = function LottieComponent_Factory(t) { return new (t || LottieComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
LottieComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LottieComponent, selectors: [["ng-lottie"]], viewQuery: function LottieComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
    } }, inputs: { width: "width", height: "height" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 6, consts: [[3, "ngStyle", "ngClass"], ["container", ""]], template: function LottieComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width || "100%")("height", ctx.height || "100%");
        ɵngcc0.ɵɵproperty("ngStyle", ctx.styles)("ngClass", ctx.containerClass);
    } }, directives: [ɵngcc1.NgStyle, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
LottieComponent.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: AnimationLoader }
];
/** @type {!Object<string, !Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
LottieComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LottieComponent, [{
        type: Component,
        args: [{
                selector: 'ng-lottie',
                template: `
    <div
      #container
      [style.width]="width || '100%'"
      [style.height]="height || '100%'"
      [ngStyle]="styles"
      [ngClass]="containerClass"
    ></div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: AnimationLoader }]; }, { width: [{
            type: Input
        }], height: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }] }); })();

class LottieModule {
    static forRoot(options) {
        return {
            ngModule: LottieModule,
            providers: [
                AnimationLoader,
                {
                    provide: LOTTIE_OPTIONS,
                    useValue: options,
                },
            ],
        };
    }
}
LottieModule.ɵfac = function LottieModule_Factory(t) { return new (t || LottieModule)(); };
LottieModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LottieModule });
LottieModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LottieModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [BaseDirective, LottieDirective, LottieComponent],
                exports: [BaseDirective, LottieDirective, LottieComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LottieModule, { declarations: function () { return [BaseDirective, LottieDirective, LottieComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [BaseDirective, LottieDirective, LottieComponent]; } }); })();

class CacheableAnimationLoader extends AnimationLoader {
    constructor() {
        super(...arguments);
        this.cache = new Map();
    }
    ngOnDestroy() {
        this.cache.clear();
    }
    loadAnimation(options) {
        return this.player$.pipe(map(player => {
            const animationItem = this.createAnimationItem(player, this.transformOptions(options));
            this.awaitConfigAndCache(options, animationItem);
            return animationItem;
        }));
    }
    awaitConfigAndCache(options, animationItem) {
        if (this.isAnimationConfigWithPath(options)) {
            // Don't wait for the `config_ready` event if it has been cached previously.
            if (this.cache.has(options.path)) {
                return;
            }
            animationItem.addEventListener('config_ready', () => {
                // See the comments below on why we're storing the animation data as a string.
                this.cache.set(options.path, JSON.stringify(animationItem['animationData']));
            });
        }
    }
    transformOptions(options) {
        if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {
            return Object.assign(Object.assign({}, options), { path: undefined, 
                // Caretaker note: `lottie-web` cannot re-use the `animationData` object between animations, and we
                // have to retrieve a new object each time an animation is created.
                // https://github.com/airbnb/lottie-web#html
                // See comments for the `animationData` property.
                animationData: JSON.parse(this.cache.get(options.path)) });
        }
        else {
            return options;
        }
    }
    isAnimationConfigWithPath(options) {
        return typeof options.path === 'string';
    }
}
CacheableAnimationLoader.ɵfac = /*@__PURE__*/ function () { let ɵCacheableAnimationLoader_BaseFactory; return function CacheableAnimationLoader_Factory(t) { return (ɵCacheableAnimationLoader_BaseFactory || (ɵCacheableAnimationLoader_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CacheableAnimationLoader)))(t || CacheableAnimationLoader); }; }();
CacheableAnimationLoader.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CacheableAnimationLoader, factory: CacheableAnimationLoader.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CacheableAnimationLoader, [{
        type: Injectable
    }], null, null); })();

class LottieCacheModule {
    static forRoot() {
        return {
            ngModule: LottieCacheModule,
            providers: [
                {
                    provide: AnimationLoader,
                    useClass: CacheableAnimationLoader,
                },
            ],
        };
    }
}
LottieCacheModule.ɵfac = function LottieCacheModule_Factory(t) { return new (t || LottieCacheModule)(); };
LottieCacheModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LottieCacheModule });
LottieCacheModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LottieCacheModule, [{
        type: NgModule
    }], null, null); })();

function transformAnimationFilenameToKey(animation) {
    const [animationName] = animation.split('.json');
    return `animation-${animationName}`;
}

class LottieTransferState {
    constructor(transferState) {
        this.transferState = transferState;
    }
    get(animation) {
        const animationKey = transformAnimationFilenameToKey(animation);
        const stateKey = makeStateKey(animationKey);
        return this.transferState.get(stateKey, null);
    }
}
LottieTransferState.ɵfac = function LottieTransferState_Factory(t) { return new (t || LottieTransferState)(ɵngcc0.ɵɵinject(ɵngcc2.TransferState)); };
/** @nocollapse */ LottieTransferState.ɵprov = i0.ɵɵdefineInjectable({ factory: function LottieTransferState_Factory() { return new LottieTransferState(i0.ɵɵinject(i1.TransferState)); }, token: LottieTransferState, providedIn: "root" });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
LottieTransferState.ctorParameters = () => [
    { type: TransferState }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LottieTransferState, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc2.TransferState }]; }, null); })();

/**
 * The public api for consumers of ngx-lottie
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AnimationLoader, BaseDirective, LottieCacheModule, LottieComponent, LottieDirective, LottieModule, LottieTransferState, transformAnimationFilenameToKey, LOTTIE_OPTIONS as ɵb, CacheableAnimationLoader as ɵc };

//# sourceMappingURL=ngx-lottie.js.map